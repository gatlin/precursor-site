[
  {
    "id": 0,
    "text_multiline": [
";; Sample 1: Asynchronous coroutines from scratch",
"; Precursor has no concept of generators or coroutines or streams, etc. ",
"; With shift, reset, !, and ?, however, we implement them in 6 lines.",
"",
"(letrec (",
"  (yield (\\ (value) (shift k (! (\\ (p) ((? p) value k))))))",
"  (generator-next (\\ (gen)",
"    (let k ( (? gen) (! (\\ (a b) b)))",
"    (k _))))",
"  (generator-view (\\ (gen)",
"    ( (? gen) (! (\\ (a b) a)))))",
"  )",
"(let gen (reset",
"  (let _ ((? yield) 1)",
"  (let _ ((? yield) 2)",
"         ((? yield) 3))))",
"(let n1 ((? generator-view) gen)",
"(let gen ((? generator-next) gen)",
"(let n2 ((? generator-view) gen)",
"(let gen ((? generator-next) gen)",
"(let n3 ((? generator-view) gen)",
"(prim-add (prim-add n1 n2) n3)))))))",
")"
    ]
  },
  {
    "id": 1,
    "text_multiline": [
";; Sample 2: If you look closely this is a pre-Cambrian Actor model. ",
"; \"An object is a poor man's closure; a closure is a poor man's object.\"",
"; — Anton van Straaten, paraphrased",
"",
"(letrec (",
"  (make-reducer (\\ (initial-value) (letrec (",
"    (loop (\\ (total first-run) (reset",
"      (let n (shift k k)",
"      (if (prim-and",
"            (prim-eq n 0)",
"            (prim-not first-run))",
"        total",
"        ((? loop) (prim-add n total) #f  ))))))",
"    )",
"    ((? loop) initial-value #t)",
"  )))",
")",
"(let the-reducer ((? make-reducer) 911177)",
"(let the-reducer (the-reducer 69)",
"(let the-reducer (the-reducer 420)",
"(the-reducer 0))))",
")"
    ]
  },
  {
    "id": 2,
    "text_multiline": [
";; Sample 3: delimited continuations by (bizarre) example",
"",
"(letrec (",
"  ; Computes the number 13 in a roundabout way.",
"  (thirteen (\\ ()",
"    ; The expression in a `shift` returns to the nearest enclosing `reset`.",
"    (let twelve (reset",
"      (let three-then-six (shift times-2  ; We can name this anything we want.",
"        (let six (times-2 3)",
"        (times-2 six)))",
"      (prim-mul 2 three-then-six)))",
"    (prim-add twelve 1))))",
" ; you thought you weren't going to see a factorial implementation today?",
" ; think again.",
" (factorial (\\ (n) (letrec (",
"   (help (\\ (n total)",
"     (let n (? n) ; ensure n fully evaluated before use with primop",
"     (let total (? total) ; see above",
"     (if (prim-lt n 2)",
"       total",
"       ( (? help) (prim-sub n 1) (prim-mul n total) ))))))",
"   )",
"   ( (? help) n 1))))",
")",
"((? factorial) (! ((? thirteen))))",
")"
    ]
  },
  {
    "id": 3,
    "text_multiline": [
";; Sample 4: Church-encoded data structure: a list",
"; A Church-encoded data structure is defined in terms of its \"catamorphism\"",
"; — a function which tears it down. There's some poetry in there.",
"",
"(letrec (",
"  ; a list is defined in terms of its so-called \"right fold\" ",
"  (foldr (\\ (fn init-value the-list)",
"    (let the-list (? the-list)",
"    ( (? the-list) fn init-value ) )))",
"",
"  ; two constructors: empty list ...",
"  (nil (\\ () (! (\\ (c e) e))))",
"",
"  ; ... and prepending an item to an existing list",
"  (cons (\\ (x xs) (! (\\ (c e)",
"    ( (? c)",
"      x",
"      (! ( (? foldr)",
"        c",
"        e",
"        xs )))))))",
")",
"(let list-1",
"  (! ((? cons) 17",
"  (! ((? cons) 20",
"  (! ((? cons) 86",
"  (! ((? nil)))))))))",
"( (? foldr)",
"    (! (\\ (a b)",
"      (let a (? a)",
"      (let b (? b)",
"      (prim-add a b)))))",
"    0",
"    list-1 ))",
")"
    ]
  },
  {
    "id": 4,
    "text_multiline": [
";; Sample 5: Effect handler example w/ State",
"; This example shows 2 things:",
"; 1. A pattern for 'effect handling', with the effect being a mutable",
";    state value; and",
"; 2. You can also define function with λ instead of \\. No difference.",
"",
"(letrec (",
"  ; \"Effect operators\" represent an effect to be performed,",
"  ; but do not contain any implementation details themselves.",
"  (load (λ () (shift k",
"    (! (λ (l _) ((? l) k))))))",
"",
"  (save (λ (v) (shift k",
"    (! (λ (_ s) ((? s) v k))))))",
"",
"  ; Note that this ignores its two arguments in order to satisfy the",
"  ; interface expected by `run-state` but otherwise stops side-effects.",
"  (return (λ (x) (shift k",
"    (! (λ (_ _) (? x))))))",
"",
"  ; Implmentation of the side-effects. In general one operator permits many",
"  ; implementations. This is a simple functional state handler.",
"  (run-state (λ (st comp)",
"    (let handle (reset (? comp))",
"    ((? handle)",
"       (! (λ (k)",
"         (let result (! (k st))",
"         ((? run-state) st result))))",
"       (! (λ (v k)",
"         (let result (! (k _))",
"         ((? run-state) v result))))))))",
"",
"  ; An example user of the above code. It increments a stateful value and",
"  ; returns the most recent value.",
"  (incr-state (λ ()",
"    (let n ((? load))",
"    (let _ ((? save) (prim-add n 1))",
"    (let result ((? load))",
"    ((? return) result))))))",
"  )",
"((? run-state) 419 (! ((? incr-state))))",
")"
    ]

  }
]
