[
  {
    "id": 0,
    "text_multiline": [
"(letrec (",
"  ; Homemade asynchronous generator / coroutine",
"  (yield (\\ (value) (shift k (! (\\ (p) ((? p) value k))))))",
"  (generator-next (\\ (gen)",
"    (let k ( (? gen) (! (\\ (a b) b)))",
"    (k _))))",
"  (generator-view (\\ (gen)",
"    ( (? gen) (! (\\ (a b) a)))))",
"  )",
"(let gen (reset",
"  (let _ ((? yield) 1)",
"  (let _ ((? yield) 2)",
"         ((? yield) 3))))",
"(let n1 ((? generator-view) gen)",
"(let gen ((? generator-next) gen)",
"(let n2 ((? generator-view) gen)",
"(let gen ((? generator-next) gen)",
"(let n3 ((? generator-view) gen)",
"(prim:add (prim:add n1 n2) n3)))))))",
")"
    ]
  },
  {
    "id": 1,
    "text_multiline": [
"(letrec (",
"  ; \"Objects are a poor man's closures;",
"  ; closures are a poor man's objects.\"",
"  ; - Anton van Straaten, paraphrased",
"  (make-reducer (\\ (initial-value) (letrec (",
"    (loop (\\ (total first-run) (reset",
"      (let n (shift k k)",
"      (if (prim:and",
"            (prim:eq n 0)",
"            (prim:not first-run))",
"        total",
"        ((? loop) (prim:add n total) #f  ))))))",
"    )",
"    ((? loop) initial-value #t)",
"  )))",
")",
"(let the-reducer ((? make-reducer) 911177)",
"(let the-reducer (the-reducer 69)",
"(let the-reducer (the-reducer 420)",
"(the-reducer 0))))",
")"
    ]
  },
  {
    "id": 2,
    "text_multiline": [
"(letrec (",
"  ; Computes the number 13 in a roundabout way.",
"  (thirteen (\\ ()",
"    ; The expression in a `shift` returns to the nearest enclosing `reset`.",
"    (let twelve (reset",
"      (let three-then-six (shift times-2  ; We can name this anything we want.",
"        (let six (times-2 3)",
"        (times-2 six)))",
"      (prim:mul 2 three-then-six)))",
"    (prim:add twelve 1))))",
" ; you thought you weren't going to see a factorial implementation today?",
" ; think again.",
" (factorial (\\ (n) (letrec (",
"   (help (\\ (n total)",
"     (let n (? n) ; ensure n fully evaluated before use with primop",
"     (let total (? total) ; see above",
"     (if (prim:lt n 2)",
"       total",
"       ( (? help) (prim:sub n 1) (prim:mul n total) ))))))",
"   )",
"   ( (? help) n 1))))",
")",
"((? factorial) (! ((? thirteen))))",
")"
    ]
  },
  {
    "id": 3,
    "text_multiline": [
"(letrec (",
"  ; a list is defined in terms of its so-called \"right fold\" ",
"  (foldr (\\ (fn init-value the-list)",
"    (let the-list (? the-list)",
"    ( (? the-list) fn init-value ) )))",
"",
"  ; two constructors: empty list ...",
"  (nil (\\ () (! (\\ (c e) e))))",
"",
"  ; ... and prepending an item to an existing list",
"  (cons (\\ (x xs) (! (\\ (c e)",
"    ( (? c)",
"      x",
"      (! ( (? foldr)",
"        c",
"        e",
"        xs )))))))",
")",
"(let list-1",
"  (! ((? cons) 17",
"  (! ((? cons) 20",
"  (! ((? cons) 86",
"  (! ((? nil)))))))))",
"( (? foldr)",
"    (! (\\ (a b)",
"      (let a (? a)",
"      (let b (? b)",
"      (prim:add a b)))))",
"    0",
"    list-1 ))",
")"
    ]
  },
  {
    "id": 4,
    "text_multiline": [
"(letrec (",
"  ;; effect handlers from scratch!",
"  ; load a dynamic state value",
"  (load (λ () (shift k",
"    (! (λ (f) ((? (prim:record-get \"load\" f)) k))))))",
"  ; ... and save a dynamic state value",
"  (save (λ (v) (shift k",
"    (! (λ (f) ((? (prim:record-get \"save\" f)) v k))))))",
"",
"  (return (λ (x) (shift k",
"    (! (λ (_) (? x))))))",
"",
"  ; implementation of the state effect handlers",
"  (run-state (λ (st comp)",
"    (let handle (reset (? comp))",
"    ((? handle) (prim:record-new",
"      \"load\" (! (λ (continue)",
"               (let res (! (continue st))",
"               ((? run-state) st res))))",
"      \"save\" (! (λ (v continue)",
"               (let res (! (continue _))",
"               ((? run-state) v res)))))))))",
"",
"  ; finally, a state-ly demo",
"  (increment-state (λ ()",
"    (let n ((? load))",
"    (let _ ((? save) (prim:add n 1))",
"    (let n-plus-1 ((? load))",
"    ((? return) n-plus-1))))))",
")",
"((? run-state) 419 (! ((? increment-state))))",
")"
    ]

  }
]
